// See LICENSE for license details.
package sifive.fpgashells.ip.xilinx

import Chisel._
import chisel3.core.{Input, Output, attach}
import chisel3.experimental.{Analog}
import freechips.rocketchip.util.{ElaborationArtefacts}

import sifive.blocks.devices.pinctrl.{BasePin}

//========================================================================
// This file contains common devices used by our Xilinx FPGA flows and some
// BlackBox modules used in the Xilinx FPGA flows
//========================================================================

//-------------------------------------------------------------------------
// IBUFDS
//-------------------------------------------------------------------------
//IP : xilinx unisim IBUFDS. SelectIO Differential Signaling Input
// Buffer unparameterized

class IBUFDS extends BlackBox {
  val io = new Bundle {
    val O         = Bool(OUTPUT)
    val I         = Bool(INPUT)
    val IB        = Bool(INPUT)
  }
}

//-------------------------------------------------------------------------
// IBUFG
//-------------------------------------------------------------------------
/** IBUFG -- Clock Input Buffer */

class IBUFG extends BlackBox {
  val io = new Bundle {
    val O = Output(Clock())
    val I = Input(Clock())
  }
}

object IBUFG {
  def apply (pin: Clock): Clock = {
    val pad = Module (new IBUFG())
    pad.io.I := pin
    pad.io.O
  }
}

//-------------------------------------------------------------------------
// IOBUF
//-------------------------------------------------------------------------
/** IOBUF -- Bidirectional IO Buffer. */

class IOBUF extends BlackBox {
  val io = new Bundle {
    val O  = Output(Bool())
    val IO = Analog(1.W)
    val I  = Input(Bool())
    val T  = Input(Bool())
  }
}

object IOBUF {
  def apply (pin: Analog, ctrl: BasePin): Bool = {
    val pad = Module(new IOBUF())
    pad.io.I    := ctrl.o.oval
    pad.io.T    := ~ctrl.o.oe
    ctrl.i.ival := pad.io.O & ctrl.o.ie
    attach(pad.io.IO, pin)
    pad.io.O & ctrl.o.ie
  }

  // Creates an output IOBUF
  def apply (pin: Analog, in: Bool): Unit = {
    val pad = Module(new IOBUF())
    pad.io.I := in
    pad.io.T := false.B
    attach(pad.io.IO, pin)
  }

  // Creates an input IOBUF
  def apply (pin: Analog): Bool = {
    val pad = Module(new IOBUF())
    pad.io.I := false.B
    pad.io.T := true.B
    attach(pad.io.IO, pin)
    pad.io.O
  }
}

//-------------------------------------------------------------------------
// PULLUP
//-------------------------------------------------------------------------
/** PULLUP : can be applied to Input to add a Pullup. */

class PULLUP extends BlackBox {
  val io = new Bundle {
    val O = Analog(1.W)
  }
}

object PULLUP {
  def apply (pin: Analog): Unit = {
    val pullup = Module(new PULLUP())
    attach(pullup.io.O, pin)
  }
}

//-------------------------------------------------------------------------
// armps: arm core in zynq zybo
//-------------------------------------------------------------------------
/** armps: This is generated by the Xilinx IP Generation Scripts */

class armps extends BlackBox {
  val io = new Bundle {
    val FCLK_CLK0     = Output(Clock())
    val FCLK_RESET0_N = Output(Bool())
  }
}

//-------------------------------------------------------------------------
// mmcm
//-------------------------------------------------------------------------
/** mmcm: This is generated by the Xilinx IP Generation Scripts */

class mmcm extends BlackBox {
  val io = new Bundle {
    val clk_in1  = Input(Clock())
    val clk_out1 = Output(Clock())
    val clk_out2 = Output(Clock())
    val clk_out3 = Output(Clock())
    val resetn   = Input(Bool())
    val locked   = Output(Bool())
  }
}

//-------------------------------------------------------------------------
// reset_sys
//-------------------------------------------------------------------------
/** reset_sys: This is generated by the Xilinx IP Generation Scripts */

class reset_sys extends BlackBox {
  val io = new Bundle {
    val slowest_sync_clk     = Input(Clock())
    val ext_reset_in         = Input(Bool())
    val aux_reset_in         = Input(Bool())
    val mb_debug_sys_rst     = Input(Bool())
    val dcm_locked           = Input(Bool())
    val mb_reset             = Output(Bool())
    val bus_struct_reset     = Output(Bool())
    val peripheral_reset     = Output(Bool())
    val interconnect_aresetn = Output(Bool())
    val peripheral_aresetn   = Output(Bool())
  }
}

//-------------------------------------------------------------------------
// reset_mig
//-------------------------------------------------------------------------
/** reset_mig: This is generated by the Xilinx IP Generation Scripts */

class reset_mig extends BlackBox {
  val io = new Bundle {
    val slowest_sync_clk     = Input(Clock())
    val ext_reset_in         = Input(Bool())
    val aux_reset_in         = Input(Bool())
    val mb_debug_sys_rst     = Input(Bool())
    val dcm_locked           = Input(Bool())
    val mb_reset             = Output(Bool())
    val bus_struct_reset     = Output(Bool())
    val peripheral_reset     = Output(Bool())
    val interconnect_aresetn = Output(Bool())
    val peripheral_aresetn   = Output(Bool())
  }
}

//-------------------------------------------------------------------------
// PowerOnResetFPGAOnly
//-------------------------------------------------------------------------
/** PowerOnResetFPGAOnly -- this generates a power_on_reset signal using
  * initial blocks.  It is synthesizable on FPGA flows only.
  */

// This is a FPGA-Only construct, which uses
// 'initial' constructions
class PowerOnResetFPGAOnly extends BlackBox {
  val io = new Bundle {
    val clock = Input(Clock())
    val power_on_reset = Output(Bool())
  }
}

object PowerOnResetFPGAOnly {
  def apply (clk: Clock): Bool = {
    val por = Module(new PowerOnResetFPGAOnly())
    por.io.clock := clk
    por.io.power_on_reset
  }
}

//-------------------------------------------------------------------------
// vc707_sys_clock_mmcm
//-------------------------------------------------------------------------
//IP : xilinx mmcm with "NO_BUFFER" input clock

class vc707_sys_clock_mmcm0 extends BlackBox {
  val io = new Bundle {
    val clk_in1   = Bool(INPUT)
    val clk_out1  = Clock(OUTPUT)
    val clk_out2  = Clock(OUTPUT)
    val clk_out3  = Clock(OUTPUT)
    val clk_out4  = Clock(OUTPUT)
    val clk_out5  = Clock(OUTPUT)
    val clk_out6  = Clock(OUTPUT)
    val clk_out7  = Clock(OUTPUT)
    val reset     = Bool(INPUT)
    val locked    = Bool(OUTPUT)
  }
  
  ElaborationArtefacts.add(
    "vc707_sys_clock_mmcm0.vivado.tcl",
    """create_ip -name clk_wiz -vendor xilinx.com -library ip -module_name vc707_sys_clock_mmcm0 -dir $ipdir -force
    set_property -dict [list \
    CONFIG.CLK_IN1_BOARD_INTERFACE {Custom} \
    CONFIG.PRIM_SOURCE {No_buffer} \
    CONFIG.CLKOUT2_USED {true} \
    CONFIG.CLKOUT3_USED {true} \
    CONFIG.CLKOUT4_USED {true} \
    CONFIG.CLKOUT5_USED {true} \
    CONFIG.CLKOUT6_USED {true} \
    CONFIG.CLKOUT7_USED {true} \
    CONFIG.CLKOUT1_REQUESTED_OUT_FREQ {12.5} \
    CONFIG.CLKOUT2_REQUESTED_OUT_FREQ {25} \
    CONFIG.CLKOUT3_REQUESTED_OUT_FREQ {37.5} \
    CONFIG.CLKOUT4_REQUESTED_OUT_FREQ {50} \
    CONFIG.CLKOUT5_REQUESTED_OUT_FREQ {100} \
    CONFIG.CLKOUT6_REQUESTED_OUT_FREQ {150.000} \
    CONFIG.CLKOUT7_REQUESTED_OUT_FREQ {75} \
    CONFIG.CLK_IN1_BOARD_INTERFACE {Custom} \
    CONFIG.PRIM_IN_FREQ {200.000} \
    CONFIG.CLKIN1_JITTER_PS {50.0} \
    CONFIG.MMCM_DIVCLK_DIVIDE {1} \
    CONFIG.MMCM_CLKFBOUT_MULT_F {4.500} \
    CONFIG.MMCM_CLKIN1_PERIOD {5.0} \
    CONFIG.MMCM_CLKOUT0_DIVIDE_F {72.000} \
    CONFIG.MMCM_CLKOUT1_DIVIDE {36} \
    CONFIG.MMCM_CLKOUT2_DIVIDE {24} \
    CONFIG.MMCM_CLKOUT3_DIVIDE {18} \
    CONFIG.MMCM_CLKOUT4_DIVIDE {9} \
    CONFIG.MMCM_CLKOUT5_DIVIDE {6} \
    CONFIG.MMCM_CLKOUT6_DIVIDE {12} \
    CONFIG.NUM_OUT_CLKS {7} \
    CONFIG.CLKOUT1_JITTER {168.247} \
    CONFIG.CLKOUT1_PHASE_ERROR {91.235} \
    CONFIG.CLKOUT2_JITTER {146.624} \
    CONFIG.CLKOUT2_PHASE_ERROR {91.235} \
    CONFIG.CLKOUT3_JITTER {135.178} \
    CONFIG.CLKOUT3_PHASE_ERROR {91.235} \
    CONFIG.CLKOUT4_JITTER {127.364} \
    CONFIG.CLKOUT4_PHASE_ERROR {91.235} \
    CONFIG.CLKOUT5_JITTER {110.629} \
    CONFIG.CLKOUT5_PHASE_ERROR {91.235} \
    CONFIG.CLKOUT6_JITTER {102.207} \
    CONFIG.CLKOUT6_PHASE_ERROR {91.235} \
    CONFIG.CLKOUT7_JITTER {117.249} \
    CONFIG.CLKOUT7_PHASE_ERROR {91.235}] [get_ips vc707_sys_clock_mmcm0] """
  )
}

class vc707_sys_clock_mmcm1 extends BlackBox {
  val io = new Bundle {
    val clk_in1   = Bool(INPUT)
    val clk_out1  = Clock(OUTPUT)
    val clk_out2  = Clock(OUTPUT)
    val reset     = Bool(INPUT)
    val locked    = Bool(OUTPUT)
  }
  
  ElaborationArtefacts.add(
    "vc707_sys_clock_mmcm1.vivado.tcl",
    """create_ip -name clk_wiz -vendor xilinx.com -library ip -module_name vc707_sys_clock_mmcm1 -dir $ipdir -force
    set_property -dict [list \
    CONFIG.CLK_IN1_BOARD_INTERFACE {Custom} \
    CONFIG.PRIM_SOURCE {No_buffer} \
    CONFIG.CLKOUT2_USED {true} \
    CONFIG.CLKOUT3_USED {false} \
    CONFIG.CLKOUT4_USED {false} \
    CONFIG.CLKOUT5_USED {false} \
    CONFIG.CLKOUT6_USED {false} \
    CONFIG.CLKOUT7_USED {false} \
    CONFIG.CLKOUT1_REQUESTED_OUT_FREQ {32.5} \
    CONFIG.CLKOUT2_REQUESTED_OUT_FREQ {65} \
    CONFIG.CLK_IN1_BOARD_INTERFACE {Custom} \
    CONFIG.PRIM_IN_FREQ {200.000} \
    CONFIG.CLKIN1_JITTER_PS {50.0} \
    CONFIG.MMCM_DIVCLK_DIVIDE {1} \
    CONFIG.MMCM_CLKFBOUT_MULT_F {4.875} \
    CONFIG.MMCM_CLKIN1_PERIOD {5.0} \
    CONFIG.MMCM_CLKOUT0_DIVIDE_F {30.000} \
    CONFIG.MMCM_CLKOUT1_DIVIDE {15} \
    CONFIG.MMCM_CLKOUT2_DIVIDE {1} \
    CONFIG.MMCM_CLKOUT3_DIVIDE {1} \
    CONFIG.MMCM_CLKOUT4_DIVIDE {1} \
    CONFIG.MMCM_CLKOUT5_DIVIDE {1} \
    CONFIG.MMCM_CLKOUT6_DIVIDE {1} \
    CONFIG.NUM_OUT_CLKS {2} \
    CONFIG.CLKOUT1_JITTER {135.973} \
    CONFIG.CLKOUT1_PHASE_ERROR {87.159} \
    CONFIG.CLKOUT2_JITTER {117.878} \
    CONFIG.CLKOUT2_PHASE_ERROR {87.159} \
    CONFIG.CLKOUT3_JITTER {131.973} \
    CONFIG.CLKOUT3_PHASE_ERROR {87.159}] \
    [get_ips vc707_sys_clock_mmcm1] """
  )
}

//-------------------------------------------------------------------------
// vc707reset
//-------------------------------------------------------------------------

class vc707reset() extends BlackBox
{
  val io = new Bundle{
    val areset = Bool(INPUT)
    val clock1 = Clock(INPUT)
    val reset1 = Bool(OUTPUT)
    val clock2 = Clock(INPUT)
    val reset2 = Bool(OUTPUT)
    val clock3 = Clock(INPUT)
    val reset3 = Bool(OUTPUT)
    val clock4 = Clock(INPUT)
    val reset4 = Bool(OUTPUT)
  }
}

//-------------------------------------------------------------------------
// sdio_spi_bridge
//-------------------------------------------------------------------------

class sdio_spi_bridge() extends BlackBox
{
  val io = new Bundle{
    val clk      = Clock(INPUT)
    val reset    = Bool(INPUT)
    val sd_cmd   = Analog(1.W)
    val sd_dat   = Analog(4.W)
    val spi_sck  = Bool(INPUT)
    val spi_cs   = Bool(INPUT)
    val spi_dq_o = Bits(INPUT,4)
    val spi_dq_i = Bits(OUTPUT,4)
  }
}
